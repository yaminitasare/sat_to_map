import tensorflow as tf
from IPython import display
from tensorflow.keras import layers
loss_object = tf.keras.losses.BinaryCrossentropy(from_logits=True)

def downsample(filters, size, apply_batchnorm=True):
 initializer = tf.random_normal_initializer(0., 0.02)

 result = tf.keras.Sequential()
 result.add(
     tf.keras.layers.Conv2D(filters, size, strides=2, padding='same',
                            kernel_initializer=initializer, use_bias=False))

 if apply_batchnorm:
   result.add(tf.keras.layers.BatchNormalization())

 result.add(tf.keras.layers.LeakyReLU())

 return result

def Discriminator():
 initializer = tf.random_normal_initializer(0., 0.02)

 inp = tf.keras.layers.Input(shape=[256, 256, 3], name='input_image')
 tar = tf.keras.layers.Input(shape=[256, 256, 3], name='target_image')

 x = tf.keras.layers.concatenate([inp, tar])

 down1 = downsample(64, 4, False)(x)
 down2 = downsample(128, 4)(down1)
 down3 = downsample(256, 4)(down2)

 zero_pad1 = tf.keras.layers.ZeroPadding2D()(down3)
 conv = tf.keras.layers.Conv2D(512, 4, strides=1,
                               kernel_initializer=initializer,
                               use_bias=False)(zero_pad1)

 batchnorm1 = tf.keras.layers.BatchNormalization()(conv)
 leaky_relu = tf.keras.layers.LeakyReLU()(batchnorm1)
 zero_pad2 = tf.keras.layers.ZeroPadding2D()(leaky_relu)
 last = tf.keras.layers.Conv2D(1, 4, strides=1,
                               kernel_initializer=initializer)(zero_pad2)
 return tf.keras.Model(inputs=[inp, tar], outputs=last)


def discriminator_loss(disc_real_output, disc_generated_output):
 real_loss = loss_object(tf.ones_like(disc_real_output), disc_real_output)
 generated_loss = loss_object(tf.zeros_like(disc_generated_output), disc_generated_output)
 total_disc_loss = real_loss + generated_loss
 return total_disc_loss
